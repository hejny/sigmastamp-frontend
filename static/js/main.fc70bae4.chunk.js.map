{"version":3,"sources":["components/UploadZone.tsx","components/Loader.tsx","components/AsyncContentComponent.tsx","oracles/_AbstractBlockcyptherOracle.ts","oracles/BitcoinOracle.ts","utils/readFile.tsx","utils/getAsByteArray.tsx","utils/uint8ArrayToHex.tsx","hash/blake2b256.ts","oracles/EthereumOracle.ts","oracles/LitecoinOracle.ts","oracles/DateOracle.ts","oracles/NytimesOracle.ts","components/PdfPage.tsx","components/PaymentGate.tsx","smartcontracts/getCurrentBlockchainHeight.ts","smartcontracts/createSigmaStampNft.ts","App.tsx","smartcontracts/validateFirstCertificate.ts","VerifyApp.tsx","index.tsx"],"names":["UploadZone","state","fileInputField","uploadClick","this","props","children","onFile","onFiles","onFileOver","onFilesOver","clickable","onFileOverMaybe","isFileOver","UploadZoneDiv","onClick","onDragEnter","event","stopPropagation","preventDefault","onDragOver","onDragExit","onDragEnd","onDrop","files","Array","from","dataTransfer","type","ref","element","click","onChange","target","React","styled","div","Loader","LoaderDiv","className","AsyncContentComponent","loading","content","setState","a","factorable","AbstractBlockcyptherOracle","name","title","dataTitles","hash","ttl","fetch","toLowerCase","response","console","log","json","body","error","Error","BitcoinOracle","readFile","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","readAsArrayBuffer","getAsByteArray","Uint8Array","uint8ArrayToHex","uint8Array","map","x","toString","padStart","join","blake2b256","input","context","blake2bInit","blake2bUpdate","hashUint8Array","blake2bFinal","EthereumOracle","LitecoinOracle","DateOracle","date","time","Date","getUTCFullYear","getUTCMonth","slice","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","NytimesOracle","firstTitle","rssParser","RssParser","parseURL","feed","items","PdfPage","pageRef","useRef","createUi","createPdf","doc","jsPDF","html2canvas","current","canvas","image","toDataURL","addImage","output","PdfPageDiv","PaymentGate","amount","address","dueTime","PaymentGateDiv","getCurrentBlockchainHeight","createSigmaStampNft","userAddress","documentHashInBase64","documentHashInHex","mintingFee","ergsSendTogetherWithNFT","ergsFeeForSigmaStampService","sigmaStampProviderAddress","assetTypeValue","returnTransactionFee","sigmaStampAssemblerNodeAddr","refundHeightThreshold","sourceInScala","JSON","stringify","trim","split","method","headers","compilerResponse","compilerResponseBody","compiledSmartContractAddress","ergoAmountRequired","documentHashInErgoFormat","verifyLinkInErgoFormat","requestBody","returnTo","startWhen","erg","txSpec","requests","ergValue","decimals","description","registers","R7","R8","R9","value","fee","inputs","dataInputs","followResponse","followResponseBody","id","getStatus","tx","detail","ORACLES","App","useState","payment","setPayment","AppDiv","length","File","certificateFile","zip","JSZip","generateAsync","zipBlob","zipHash","saveAs","substring","prompt","oracle","getData","data","Object","entries","key","to","validateFirstCertificate","firstCertificate","item","additionalRegisters","getTransactionTime","txId","timestamp","summary","tokenId","outputs","assets","getAssetHolders","VerifyApp","setFiles","verification","setVerification","hodlers","VerifyAppDiv","alert","history","createHashHistory","ReactDOM","render","StrictMode","exact","path","document","getElementById"],"mappings":"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","file":"static/js/main.fc70bae4.chunk.js","sourcesContent":["import * as React from 'react';\nimport styled from 'styled-components';\n\nexport type IUploadZoneProps = React.PropsWithChildren<{\n    clickable?: boolean;\n    onFilesOver?: (isFileOver: boolean) => void;\n    onFiles: (file: File[]) => void;\n}>;\n\nexport interface IUploadZoneState {}\n\nexport class UploadZone extends React.Component<IUploadZoneProps, IUploadZoneState> {\n    state: IUploadZoneState = { fileInputField: null };\n\n    render() {\n        const { children, onFiles: onFile, onFilesOver: onFileOver, clickable } = this.props;\n        const onFileOverMaybe = (isFileOver: boolean) => {\n            if (onFileOver) {\n                onFileOver(isFileOver);\n            }\n        };\n\n        let uploadClick: () => void;\n\n        return (\n            <UploadZoneDiv\n                onClick={() => {\n                    if (clickable) {\n                        uploadClick();\n                    }\n                }}\n                onDragEnter={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }}\n                onDragOver={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    onFileOverMaybe(true);\n                }}\n                onDragExit={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    onFileOverMaybe(false);\n                }}\n                onDragEnd={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }}\n                onDrop={(event) => {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    onFileOverMaybe(false);\n\n                    const files = Array.from(event.dataTransfer.files); // TODO: Maybe there should be event.dataTransfer.items handler\n                    onFile(files);\n                }}\n            >\n                <input\n                    type=\"file\"\n                    ref={(element) => {\n                        if (element) {\n                            uploadClick = () => {\n                                onFileOverMaybe(true);\n                                (element as HTMLInputElement).click();\n                            };\n                        }\n                    }}\n                    onChange={(event) => {\n                        if (!event || !event.target || !event.target.files) return;\n                        onFile(Array.from(event.target.files));\n                    }}\n                />\n\n                {children}\n            </UploadZoneDiv>\n        );\n    }\n}\n\nconst UploadZoneDiv = styled.div`\n    width: ${210}px;\n    height: ${297}px;\n    padding: 10px;\n    border: 5px dashed #009edf;\n\n    input {\n        display: none;\n    }\n`;\n","import * as React from 'react';\nimport styled from 'styled-components';\n\nexport function Loader() {\n    return (\n        <LoaderDiv>\n            {/* TODO: Please @roseckyj  loader that would cover only its area not the whole modal, */}\n            {/* TODO: Please @roseckyj make it universal to use it in every layout type - small icon, fullscreen, modal, etc,... */}\n            {/* TODO: Please @roseckyj untite with LoaderInline */}\n            <div className=\"spinner\"></div>\n        </LoaderDiv>\n    );\n}\n\nconst LoaderDiv = styled.div`\n\n`;\n","import * as React from 'react';\nimport { Loader } from './Loader';\n\nexport type IAwaitable<T> = T | Promise<T>;\n\nexport type IFactory<T> = () => T;\n\nexport type IFactorable<T> = T | IFactory<T>;\n\n\nexport function factor<T>(factorable: IFactorable<T>): T {\n    if (typeof factorable === 'function') {\n        return (factorable as any)();\n    } else {\n        return factorable;\n    }\n}\n\ninterface IAsyncContentComponentProps {\n    /**\n     * Component to be rendered before the content is loaded\n     *\n     * If not set, default loading is used\n     */\n    loading?: JSX.Element;\n\n    /**\n     * The async content to be rendered\n     */\n    content: IFactorable<IAwaitable<JSX.Element>>;\n}\n\ninterface IAsyncContentComponentState {\n    content: JSX.Element;\n}\n\n/**\n * Utility for mounting RxJS observable content\n *\n * @collboard-modules-sdk\n */\nexport function AsyncContentComponent({ loading, content }: IAsyncContentComponentProps) {\n    const [state, setState] = React.useState<IAsyncContentComponentState>({ content: loading || <Loader /> });\n\n    React.useEffect(() => {\n        (async () => {\n            setState({ content: await factor(content) });\n        })();\n\n        return () => {\n            /* TODO: Can here be some reasonable teardown logic? */\n        };\n    }, [content]);\n\n    return <>{state.content}</>;\n}","import { IOracle } from './_IOracle';\n\nexport abstract class AbstractBlockcyptherOracle implements IOracle<{ hash: string }> {\n    public abstract name: string;\n    public abstract title: string;\n\n    public dataTitles = { hash: 'Current block hash' };\n    public ttl = -1;\n\n    public async getData() {\n        const response = await fetch(\n            `https://api.blockcypher.com/v1/${this.name.toLowerCase()}/main` /*`https://blockchain.info/latestblock`*/,\n            /*{ mode: 'no-cors' }*/\n        );\n        console.log({ response });\n        const body = await response.json();\n\n        if (body.error) {\n            throw new Error(body.error);\n        }\n\n        const { hash } = body;\n        return { hash };\n    }\n}\n","import { AbstractBlockcyptherOracle } from \"./_AbstractBlockcyptherOracle\";\n\nexport class BitcoinOracle extends AbstractBlockcyptherOracle {\n    public name = 'BTC';\n    public title = 'Bitcoin';\n}","export function readFile(file: File | Blob): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        // Create file reader\n        let reader = new FileReader();\n\n        // Register event listeners\n        reader.addEventListener('loadend', (event) => resolve(event.target!.result as ArrayBuffer));\n        reader.addEventListener('error', reject);\n\n        // Read file\n        reader.readAsArrayBuffer(file);\n    });\n}\n","import { readFile } from './readFile';\n\nexport async function getAsByteArray(file: File|Blob): Promise<Uint8Array> {\n  return new Uint8Array(await readFile(file));\n}\n","export function uint8ArrayToHex(uint8Array: Uint8Array) {\n  return [...uint8Array].map(x => x.toString(16).padStart(2, '0')).join('');\n}\n","// @ts-ignore: no typings\nimport { blake2bInit, blake2bUpdate, blake2bFinal } from 'blakejs';\nimport { getAsByteArray } from '../utils/getAsByteArray';\nimport { uint8ArrayToHex } from '../utils/uint8ArrayToHex';\n\nexport async function blake2b256(input: File | Blob): Promise<string> {\n    const KEY = null; // optional key\n    const OUTPUT_LENGTH = 32; // bytes\n    const context = blake2bInit(OUTPUT_LENGTH, KEY);\n\n    // each time you get a byte array from the stream:\n    blake2bUpdate(context, await getAsByteArray(input));\n\n    // finally, once the stream has been exhausted\n    const hashUint8Array = blake2bFinal(context);\n    // returns a 64-byte hash, as a Uint8Array\n\n    const hash = uint8ArrayToHex(hashUint8Array);\n\n    return hash;\n}\n","import { AbstractBlockcyptherOracle } from \"./_AbstractBlockcyptherOracle\";\n\nexport class EthereumOracle extends AbstractBlockcyptherOracle {\n    public name = 'ETH';\n    public title = 'Ethereum';\n}","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class LitecoinOracle extends AbstractBlockcyptherOracle {\n    public name = 'LTC';\n    public title = 'Litecoin';\n}\n","import { IOracle } from './_IOracle';\n\nexport class DateOracle implements IOracle<{ date: string; time: string }> {\n    public name = 'DATE';\n    public title = 'Current';\n    public ttl = 1;\n\n    public dataTitles = { date: 'date', time: 'time' };\n\n    public getData() {\n        const date = new Date();\n        return {\n            date: `${date.getUTCFullYear()}-${('0' + date.getUTCMonth()).slice(-2)}-${('0' + date.getUTCDate()).slice(\n                -2,\n            )}`,\n            time: `${('0' + date.getUTCHours()).slice(-2)}:${('0' + date.getUTCMinutes()).slice(-2)}:${(\n                '0' + date.getUTCSeconds()\n            ).slice(-2)}`,\n        };\n    }\n}\n","import RssParser from 'rss-parser';\nimport { IOracle } from './_IOracle';\n\nexport class NytimesOracle implements IOracle<{ firstTitle: string }> {\n    public name = 'NYTIMES';\n    public title = 'The New York Times';\n    public ttl = -1;\n\n    public dataTitles = { firstTitle: 'first title' };\n\n    public async getData() {\n        const rssParser = new RssParser();\n        const feed = await rssParser.parseURL(`https://rss.nytimes.com/services/xml/rss/nyt/World.xml`);\n\n        // console.log({ feed });\n\n        return {\n            firstTitle: feed.items[0].title as string,\n        };\n    }\n}\n","import React, { useRef } from 'react';\nimport styled from 'styled-components';\nimport { IAwaitable } from './AsyncContentComponent';\nimport { jsPDF } from 'jspdf';\nimport html2canvas from 'html2canvas';\n\ninterface PdfPage extends React.PropsWithChildren<{}> {\n    createUi: (options: { createPdf: () => Promise<Blob> }) => IAwaitable<JSX.Element | JSX.Element[]>;\n}\n\nexport function PdfPage(props: PdfPage) {\n    const pageRef = useRef(null);\n\n    return (\n        <div>\n            {props.createUi({\n                createPdf: async () => {\n                    const doc = new jsPDF();\n\n                    // TODO: !!! Through nice html2canvas\n\n                    const canvas = await html2canvas(pageRef!.current!);\n                    const image = canvas.toDataURL();\n\n                    // !!! document.body.appendChild(canvas);\n\n                    doc.addImage(image, 'JPEG', 0, 0, 210, 297);\n                    //doc.text(`Your BLAKE2b file hash is`, 10, 10);\n\n                    return doc.output('blob');\n                },\n            })}\n            <PdfPageDiv ref={pageRef}>{props.children}</PdfPageDiv>\n        </div>\n    );\n}\n\nconst PdfPageDiv = styled.div`\n    width: ${210 * 2}px;\n    height: ${297 * 2}px;\n    border: 2px solid #009edf;\n\n    background-color: white;\n    color: black;\n\n    button {\n    }\n`;\n","import * as React from 'react';\nimport styled from 'styled-components';\n\nexport interface IPaymentGateProps {\n    amount: number;\n    address: string;\n    dueTime: number /* TODOL Date */;\n    //getStatus: () => Promise<boolean /* full status in future */>;\n}\n\nexport function PaymentGate({ amount, address, dueTime /*, getStatus*/ }: IPaymentGateProps) {\n    return (\n        <PaymentGateDiv>\n            Pay {amount} ERG to address {address} in ${dueTime} seconds.\n            {/*<button\n                onClick={async () => {\n                    const status = await getStatus();\n                    if (status) {\n                        alert(`Payed`)!;\n                    }\n                }}\n            ></button>*/}\n        </PaymentGateDiv>\n    );\n}\n\nconst PaymentGateDiv = styled.div``;\n","export async function getCurrentBlockchainHeight(): Promise<number> {\n    // TODO: Implement, value is hardcoded\n    return 0;\n}\n","import { getCurrentBlockchainHeight } from './getCurrentBlockchainHeight';\nimport { isUserAddressCorrect } from './isUserAddressCorrect';\n\ninterface ICreateSigmaStampNft {\n    documentHashInBase64: string;\n    documentHashInHex: string;\n    userAddress: string;\n}\n\nexport async function createSigmaStampNft({\n    userAddress,\n    documentHashInBase64,\n    documentHashInHex,\n}: ICreateSigmaStampNft) /*: Promise<{ amount: number; address: string }> */ {\n    if (!isUserAddressCorrect(userAddress)) {\n        throw new Error(`User address \"${userAddress}\" is not correct.`);\n    }\n\n    const mintingFee = 20000000; /* TODO: User settable */\n    const ergsSendTogetherWithNFT = 100000000; /* TODO: User settable */\n    const ergsFeeForSigmaStampService = 100000000; /* Our fee */\n    const sigmaStampProviderAddress = '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV';\n    const assetTypeValue = 'Ad4=';\n    const returnTransactionFee = 10000000;\n    const sigmaStampAssemblerNodeAddr = '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV';\n    const refundHeightThreshold = (await getCurrentBlockchainHeight()) + 10;\n\n    const sourceInScala = `\n{\n\n    val sigmaStampNftIssuanceOK = {\n        \n        val assetType = OUTPUTS(0).R7[Coll[Byte]].get\n        val stampedDocHash = OUTPUTS(0).R8[Coll[Byte]].get\n        val issued = OUTPUTS(0).tokens.getOrElse(0, (INPUTS(0).id, 0L))\n\n        INPUTS(0).id == issued._1 && issued._2 == 1 &&\n        OUTPUTS(0).value == ${ergsSendTogetherWithNFT}L &&\n\n        OUTPUTS(0).propositionBytes == PK(\"${userAddress}\").propBytes &&\n        OUTPUTS(1).value == ${ergsFeeForSigmaStampService}L &&\n\n        OUTPUTS(1).propositionBytes == PK(\"${sigmaStampProviderAddress}\").propBytes &&\n        assetType == fromBase64(\"${assetTypeValue}\") &&\n        stampedDocHash == fromBase64(\"${documentHashInBase64}\") &&\n        OUTPUTS.size == 3\n\n    }\n\n    val returnFunds = {\n\n        val total_without_fee = INPUTS.fold(0L, {(x:Long, b:Box) => x + b.value}) - ${returnTransactionFee}L\n\n        OUTPUTS(0).value >= total_without_fee &&\n        OUTPUTS(0).propositionBytes == PK(\"${userAddress}\").propBytes &&\n        (PK(\"${sigmaStampAssemblerNodeAddr}\") || HEIGHT > ${refundHeightThreshold}) &&\n        OUTPUTS.size == 2\n\n    }\n\n    sigmaProp(sigmaStampNftIssuanceOK || returnFunds)\n\n}\n    `;\n\n    const body = JSON.stringify(sourceInScala.trim()).split('^\\n').join('\\n').split('\\n\\n').join('\\n');\n\n    //console.log(sourceInScala, body, bodyx);\n\n    const compilerResponse = await fetch(`http://assembler.sigmastamp.ml:14747/compile`, {\n        method: 'POST',\n        body,\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    const compilerResponseBody = await compilerResponse.json();\n\n    const compiledSmartContractAddress = compilerResponseBody.address;\n    const ergoAmountRequired = ergsSendTogetherWithNFT + ergsFeeForSigmaStampService + mintingFee;\n    const documentHashInErgoFormat = `e20${documentHashInHex}`;\n    const verifyLinkInErgoFormat = `0e61${\n        /* !!! Convert to hex */ `http://sigmastamp.ml/verify?hash=a16d5705c031866f5c5dd1ba39e43538193b45718af5a50a115e1c8d67c209cd`\n    }`;\n\n    const requestBody = {\n        address: compiledSmartContractAddress,\n        returnTo: userAddress,\n        startWhen: { erg: ergoAmountRequired },\n        txSpec: {\n            requests: [\n                {\n                    ergValue: ergsSendTogetherWithNFT,\n                    address: userAddress,\n                    name: 'SigmaStampNFT',\n                    amount: 1,\n                    decimals: 0,\n                    description:\n                        'Proof of existence of document with Blake2b-256 hash specified in R8 register during minting of this NFT token.',\n                    registers: { R7: '0e0201de', R8: documentHashInErgoFormat, R9: verifyLinkInErgoFormat },\n                },\n                { value: ergsFeeForSigmaStampService, address: sigmaStampProviderAddress },\n            ],\n            fee: mintingFee,\n            inputs: ['$userIns'],\n            dataInputs: [],\n        },\n    };\n\n    const followResponse = await fetch(`http://assembler.sigmastamp.ml:14747/follow`, {\n        method: 'POST',\n        body: JSON.stringify(requestBody),\n    });\n\n    const followResponseBody = await followResponse.json();\n    const { id, dueTime } = followResponseBody;\n\n    return {\n        amount: ergoAmountRequired / 1000000000,\n        address: compilerResponseBody.address,\n        dueTime,\n        async getStatus() {\n            // Loop\n            const watchResponse = fetch(`http://assembler.sigmastamp.ml:14747/result/${id}`);\n            const watchResponseBody = await followResponse.json();\n            const { /*id,*/ tx, detail /* pending, returning, mined, success, timeout, returnFailed */ } =\n                followResponseBody;\n\n            if (detail === 'success') {\n                // !!! And now take tx and create big certificate\n\n                return true;\n            }\n\n            return false;\n        },\n    };\n}\n","import React, { useState } from 'react';\nimport { UploadZone } from './components/UploadZone';\nimport styled from 'styled-components';\nimport { createCertificate } from './pdf/createCertificate';\nimport JSZip from 'jszip';\nimport { saveAs } from 'file-saver';\nimport { AsyncContentComponent } from './components/AsyncContentComponent';\nimport { BitcoinOracle } from './oracles/BitcoinOracle';\nimport { blake2b256 } from './hash/blake2b256';\nimport { EthereumOracle } from './oracles/EthereumOracle';\nimport { LitecoinOracle } from './oracles/LitecoinOracle';\nimport { DateOracle } from './oracles/DateOracle';\nimport { NytimesOracle } from './oracles/NytimesOracle';\n// @ts-ignore: no typings\nimport html2pdf from 'html2pdf.js';\nimport html2canvas from 'html2canvas';\nimport { PdfPage } from './components/PdfPage';\nimport { PaymentGate, IPaymentGateProps } from './components/PaymentGate';\nimport { createSigmaStampNft } from './smartcontracts/createSigmaStampNft';\nimport { Link } from 'react-router-dom';\n\nconst ORACLES = [\n    new BitcoinOracle(),\n    new EthereumOracle(),\n    new LitecoinOracle(),\n    new DateOracle(),\n    new NytimesOracle(),\n];\n\ninterface IAppState {\n    files: File[];\n}\n\nexport function App() {\n    const [state, setState] = useState<IAppState>({ files: [] });\n    const [payment, setPayment] = useState<null | IPaymentGateProps>(null);\n\n    if (!payment) {\n        return (\n            <AppDiv>\n                {/*\n        <button\n          onClick={() => { console.log('test'); createCertificate() }}\n        >\n          Create document\n        </button>\n            <h1>Sigmastamp</h1>*/}\n\n                {state.files.length === 0 ? (\n                    <UploadZone\n                        onFiles={async (files) => {\n                            setState({ files });\n                            /*\n                    const file = files[0];\n\n                    const hash = await blake2b256(file);\n\n                    console.log({ files, file, hash });\n\n                    const certificateFile = createCertificate({ certificateFilename: 'certificate.pdf', hash });\n\n                    const zip = new JSZip();\n                    zip.file(file.name, file);\n                    zip.file(certificateFile.name, certificateFile);\n\n                    const zipFile = await zip.generateAsync({ type: 'blob' });\n                    saveAs(zipFile, 'certificate.zip');\n                    */\n                        }}\n                        clickable\n                    >\n                        Upload your file(s) here!\n                    </UploadZone>\n                ) : (\n                    <PdfPage\n                        createUi={({ createPdf }) => {\n                            return (\n                                <button\n                                    onClick={async () => {\n                                        const certificateFile = new File(\n                                            [await createPdf()],\n                                            'certificate1.pdf' /* TODO: Maybe add current {lastModified: 1534584790000}*/,\n                                        );\n\n                                        //saveAs(certificateFile);\n\n                                        const zip = new JSZip();\n                                        for (const file of state.files) {\n                                            zip.file(file.name, file);\n                                        }\n                                        zip.file(certificateFile.name, certificateFile);\n\n                                        const zipBlob = await zip.generateAsync({ type: 'blob' });\n\n                                        const zipHash = await blake2b256(zipBlob);\n                                        saveAs(zipBlob, `certificate1.${zipHash.substring(0, 5)}.zip`);\n\n                                        const userAddress = prompt(\n                                            'Please fill your Ergo address',\n                                            '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV' /* !!! Unhardocde */,\n                                        );\n                                        if (!userAddress) {\n                                            return;\n                                        }\n\n                                        const payment = await createSigmaStampNft({\n                                            userAddress,\n                                            documentHashInBase64: zipHash,\n                                            documentHashInHex: zipHash,\n                                        });\n\n                                        setPayment(payment);\n                                    }}\n                                >\n                                    Create 1st certificate\n                                </button>\n                            );\n                        }}\n                    >\n                        {state.files.map((file) => (\n                            <AsyncContentComponent\n                                key={file.name}\n                                content={async () => {\n                                    const hash = await blake2b256(file);\n                                    return (\n                                        <>\n                                            <b>Hash of {file.name}</b> is {hash}\n                                        </>\n                                    );\n                                }}\n                            />\n                        ))}\n\n                        {ORACLES.map((oracle) => (\n                            <div key={oracle.name}>\n                                <AsyncContentComponent\n                                    content={async () => {\n                                        const data = await oracle.getData();\n\n                                        return (\n                                            <>\n                                                {Object.entries(data).map(([key, value]) => (\n                                                    <div key={key}>\n                                                        <b>\n                                                            {/* @ts-ignore: Object.entries is dummy and cannot pass propper index signature type */}\n                                                            {oracle.title} {oracle.dataTitles[key]}:\n                                                        </b>{' '}\n                                                        {value}\n                                                    </div>\n                                                ))}\n                                            </>\n                                        );\n                                    }}\n                                />\n                            </div>\n                        ))}\n                    </PdfPage>\n                )}\n\n                <Link to=\"/verify\" target={\"_blank\"} >Or verify your 1st certificate.</Link>\n            </AppDiv>\n        );\n    } else {\n        return <PaymentGate {...payment} />;\n    }\n}\n\nconst AppDiv = styled.div`\n    a {\n        color: #555;\n        font-size: 0.7em;\n    }\n`;\n","import { blake2b256 } from '../hash/blake2b256';\n\nexport async function validateFirstCertificate(firstCertificate: File) {\n    const response = await fetch(`https://api-testnet.ergoplatform.com/api/v0/assets/issuingBoxes`);\n    const body = await response.json();\n\n    const hash = await blake2b256(firstCertificate);\n\n    for (const item of body.items) {\n        if (item.additionalRegisters['R8'] === `0e20${hash}`) {\n            return item;\n            // TODO: probbably last not first\n        }\n    }\n\n    return null;\n}\n\nexport async function getTransactionTime(txId: string) {\n    const response = await fetch(`https://api-testnet.ergoplatform.com/api/v0/transactions/${txId}`);\n    const body = await response.json();\n    console.log('getTransactionTime', body);\n    const timestamp = body.summary.timestamp;\n    const tokenId = body.outputs[0].assets[0].tokenId\n\n    return {timestamp,tokenId}\n}\n\nexport async function getAssetHolders(tokenId: string) {\n    const response = await fetch(`https://api-testnet.ergoplatform.com/api/v0/addresses/assetHolders/${tokenId}`);\n    const body = await response.json();\n    console.log('getAssetHolders', body);\n    return body;\n}\n","import React, { useState } from 'react';\nimport { UploadZone } from './components/UploadZone';\nimport styled from 'styled-components';\nimport { blake2b256 } from './hash/blake2b256';\nimport {\n    getAssetHolders,\n    getTransactionTime,\n    validateFirstCertificate,\n} from './smartcontracts/validateFirstCertificate';\nimport { PdfPage } from './components/PdfPage';\nimport JSZip from 'jszip';\nimport { Link } from 'react-router-dom';\n\nexport function VerifyApp() {\n    const [files, setFiles] = useState<any>([]);\n    const [verification, setVerification] = useState<any>(null);\n\n    if (!verification) {\n        return (\n            <VerifyAppDiv>\n                <UploadZone\n                    onFiles={async (files) => {\n                        const firstCertificate = files[0];\n                        setFiles([files[0]]);\n\n                        const verification = await validateFirstCertificate(firstCertificate);\n\n                        if (!verification) {\n                            alert(`Your 1st certificate is still not validated through Ergo blockchain.`);\n                        }\n\n                        const { txId } = verification;\n\n                        const { timestamp, tokenId } = await getTransactionTime(txId);\n                        const hodlers = await getAssetHolders(tokenId);\n\n                        setVerification({ ...verification, timestamp, tokenId, hodlers });\n                        console.log(verification);\n                    }}\n                    clickable\n                >\n                    Upload your 1st certificate.\n                </UploadZone>\n                <Link to=\"/\" target={'_blank'}>\n                    Or create your 1st certificate.\n                </Link>\n            </VerifyAppDiv>\n        );\n    } else {\n        return (\n            <PdfPage\n                createUi={({ createPdf }) => {\n                    return (\n                        <button\n                            onClick={async () => {\n                                const certificateFile = new File(\n                                    [await createPdf()],\n                                    'certificate2.pdf' /* TODO: Maybe add current {lastModified: 1534584790000}*/,\n                                );\n\n                                //saveAs(certificateFile);\n\n                                const zip = new JSZip();\n                                for (const file of files) {\n                                    zip.file(file.name, file);\n                                }\n                                zip.file(certificateFile.name, certificateFile);\n\n                                const zipBlob = await zip.generateAsync({ type: 'blob' });\n\n                                const zipHash = await blake2b256(zipBlob);\n                                saveAs(zipBlob, `certificate2.${zipHash.substring(0, 5)}.zip`);\n                            }}\n                        >\n                            Create 2nd certificate\n                        </button>\n                    );\n                }}\n            >\n                <b>txId:</b> {verification.txId}\n                <br />\n                <b>timestamp:</b> {verification.timestamp}\n                <br />\n                <b>tokenId:</b> {verification.tokenId}\n                <br />\n                <b>hodlers:</b> {verification.hodlers.join(', ')}\n            </PdfPage>\n        );\n    }\n}\n\nconst VerifyAppDiv = styled.div`\n    a {\n        color: #555;\n        font-size: 0.7em;\n    }\n`;\n","import ReactDOM from 'react-dom';\nimport { App } from './App';\nimport './index.css';\nimport { createHashHistory, History } from 'history';\nimport { Route, Router, Switch } from 'react-router-dom';\nimport React from 'react';\nimport { VerifyApp } from './VerifyApp';\n\nconst history = createHashHistory();\n\nReactDOM.render(\n    <React.StrictMode>\n        <Router {...{ history: history }}>\n            <Switch>\n                <Route exact path=\"/\">\n                    <App />\n                </Route>\n                <Route exact path=\"/verify\">\n                    <VerifyApp />\n                </Route>\n            </Switch>\n        </Router>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}