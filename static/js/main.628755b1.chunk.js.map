{"version":3,"sources":["components/Loader.tsx","components/AsyncContentComponent.tsx","components/PaymentGate.tsx","components/PdfPage.tsx","components/UploadZone.tsx","utils/readFile.tsx","utils/getAsByteArray.tsx","utils/uint8ArrayToHex.tsx","hash/blake2b256.ts","oracles/_AbstractBlockcyptherOracle.ts","oracles/BitcoinOracle.ts","oracles/DateOracle.ts","oracles/EthereumOracle.ts","oracles/LitecoinOracle.ts","oracles/NytimesOracle.ts","smartcontracts/getCurrentBlockchainHeight.ts","smartcontracts/createSigmaStampNft.ts","App.tsx","smartcontracts/validateFirstCertificate.ts","VerifyApp.tsx","index.tsx"],"names":["Loader","LoaderDiv","className","styled","div","AsyncContentComponent","loading","content","React","state","setState","a","factorable","PaymentGate","amount","address","dueTime","PaymentGateDiv","PdfPage","props","pageRef","useRef","createUi","createPdf","doc","jsPDF","text","current","innerText","output","PdfPageDiv","ref","children","UploadZone","fileInputField","uploadClick","this","onFile","onFiles","onFileOver","onFilesOver","clickable","onFileOverMaybe","isFileOver","UploadZoneDiv","onClick","onDragEnter","event","stopPropagation","preventDefault","onDragOver","onDragExit","onDragEnd","onDrop","files","Array","from","dataTransfer","type","element","click","onChange","target","readFile","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","readAsArrayBuffer","getAsByteArray","Uint8Array","uint8ArrayToHex","uint8Array","map","x","toString","padStart","join","blake2b256","input","context","blake2bInit","blake2bUpdate","hashUint8Array","blake2bFinal","hash","AbstractBlockcyptherOracle","name","title","dataTitles","ttl","fetch","toLowerCase","response","console","log","json","body","error","Error","BitcoinOracle","DateOracle","date","time","Date","getUTCFullYear","getUTCMonth","slice","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","EthereumOracle","LitecoinOracle","NytimesOracle","firstTitle","rssParser","RssParser","parseURL","feed","items","getCurrentBlockchainHeight","createSigmaStampNft","userAddress","documentHashInBase64","documentHashInHex","mintingFee","ergsSendTogetherWithNFT","ergsFeeForSigmaStampService","sigmaStampProviderAddress","assetTypeValue","returnTransactionFee","sigmaStampAssemblerNodeAddr","refundHeightThreshold","sourceInScala","JSON","stringify","trim","split","method","headers","compilerResponse","compilerResponseBody","compiledSmartContractAddress","ergoAmountRequired","documentHashInErgoFormat","verifyLinkInErgoFormat","requestBody","returnTo","startWhen","erg","txSpec","requests","ergValue","decimals","description","registers","R7","R8","R9","value","fee","inputs","dataInputs","followResponse","followResponseBody","id","getStatus","watchResponse","watchResponseBody","tx","detail","ORACLES","App","useState","payment","setPayment","AppDiv","length","File","certificateFile","zip","JSZip","generateAsync","zipBlob","zipHash","saveAs","substring","prompt","oracle","getData","data","Object","entries","key","to","validateFirstCertificate","firstCertificate","item","additionalRegisters","getTransactionTime","txId","timestamp","summary","tokenId","outputs","assets","getAssetHolders","VerifyApp","setFiles","verification","setVerification","hodlers","VerifyAppDiv","alert","history","createHashHistory","HeaderElement","header","ReactDOM","render","StrictMode","exact","path","document","getElementById"],"mappings":"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","file":"static/js/main.628755b1.chunk.js","sourcesContent":["import * as React from 'react';\nimport styled from 'styled-components';\n\nexport function Loader() {\n    return (\n        <LoaderDiv>\n            {/* TODO: Please @roseckyj  loader that would cover only its area not the whole modal, */}\n            {/* TODO: Please @roseckyj make it universal to use it in every layout type - small icon, fullscreen, modal, etc,... */}\n            {/* TODO: Please @roseckyj untite with LoaderInline */}\n            <div className=\"spinner\"></div>\n        </LoaderDiv>\n    );\n}\n\nconst LoaderDiv = styled.div``;\n","import * as React from 'react';\nimport { Loader } from './Loader';\n\nexport type IAwaitable<T> = T | Promise<T>;\n\nexport type IFactory<T> = () => T;\n\nexport type IFactorable<T> = T | IFactory<T>;\n\nexport function factor<T>(factorable: IFactorable<T>): T {\n    if (typeof factorable === 'function') {\n        return (factorable as any)();\n    } else {\n        return factorable;\n    }\n}\n\ninterface IAsyncContentComponentProps {\n    /**\n     * Component to be rendered before the content is loaded\n     *\n     * If not set, default loading is used\n     */\n    loading?: JSX.Element;\n\n    /**\n     * The async content to be rendered\n     */\n    content: IFactorable<IAwaitable<JSX.Element>>;\n}\n\ninterface IAsyncContentComponentState {\n    content: JSX.Element;\n}\n\n/**\n * Utility for mounting RxJS observable content\n *\n * @collboard-modules-sdk\n */\nexport function AsyncContentComponent({\n    loading,\n    content,\n}: IAsyncContentComponentProps) {\n    const [state, setState] = React.useState<IAsyncContentComponentState>({\n        content: loading || <Loader />,\n    });\n\n    React.useEffect(() => {\n        (async () => {\n            setState({ content: await factor(content) });\n        })();\n\n        return () => {\n            /* TODO: Can here be some reasonable teardown logic? */\n        };\n    }, [content]);\n\n    return <>{state.content}</>;\n}\n","import * as React from 'react';\nimport styled from 'styled-components';\n\nexport interface IPaymentGateProps {\n    amount: number;\n    address: string;\n    dueTime: number /* TODOL Date */;\n    //getStatus: () => Promise<boolean /* full status in future */>;\n}\n\nexport function PaymentGate({\n    amount,\n    address,\n    dueTime /*, getStatus*/,\n}: IPaymentGateProps) {\n    return (\n        <PaymentGateDiv>\n            Pay {amount} ERG to address {address} in ${dueTime} seconds.\n            {/*<button\n                onClick={async () => {\n                    const status = await getStatus();\n                    if (status) {\n                        alert(`Payed`)!;\n                    }\n                }}\n            ></button>*/}\n        </PaymentGateDiv>\n    );\n}\n\nconst PaymentGateDiv = styled.div``;\n","import { jsPDF } from 'jspdf';\nimport React, { useRef } from 'react';\nimport styled from 'styled-components';\nimport { IAwaitable } from './AsyncContentComponent';\n//import html2canvas from 'html2canvas';\n\ninterface IPdfPageProps extends React.PropsWithChildren<{}> {\n    createUi: (options: {\n        createPdf: () => Promise<Blob>;\n    }) => IAwaitable<JSX.Element | JSX.Element[]>;\n}\n\nexport function PdfPage(props: IPdfPageProps) {\n    const pageRef = useRef(null);\n\n    return (\n        <div>\n            {props.createUi({\n                createPdf: async () => {\n                    const doc = new jsPDF();\n\n                    // TODO: !!! Through nice html2canvas\n\n                    //const canvas = await html2canvas(pageRef!.current!);\n                    //const image = canvas.toDataURL();\n\n                    // !!! document.body.appendChild(canvas);\n\n                    //doc.addImage(image, 'JPEG', 0, 0, 210, 297);\n                    //doc.html((pageRef!.current as any).innerHTML, { x: 10, y: 10 });\n\n                    //console.log(pageRef!.current as any);\n                    //console.log((pageRef!.current as any).innerText);\n                    //doc.html((pageRef!.current as any).innerHTML, { x: 10, y: 10 });\n                    doc.text((pageRef!.current as any).innerText, 10, 10);\n\n                    return doc.output('blob');\n                },\n            })}\n            <PdfPageDiv ref={pageRef}>{props.children}</PdfPageDiv>\n        </div>\n    );\n}\n\nconst PdfPageDiv = styled.div`\n    width: ${210 * 2}px;\n    height: ${297 * 2}px;\n    border: 2px solid #009edf;\n\n    background-color: white;\n    color: black;\n`;\n","import * as React from 'react';\nimport styled from 'styled-components';\n\nexport type IUploadZoneProps = React.PropsWithChildren<{\n    clickable?: boolean;\n    onFilesOver?: (isFileOver: boolean) => void;\n    onFiles: (file: File[]) => void;\n}>;\n\nexport interface IUploadZoneState {}\n\nexport class UploadZone extends React.Component<\n    IUploadZoneProps,\n    IUploadZoneState\n> {\n    state: IUploadZoneState = { fileInputField: null };\n\n    render() {\n        const {\n            children,\n            onFiles: onFile,\n            onFilesOver: onFileOver,\n            clickable,\n        } = this.props;\n        const onFileOverMaybe = (isFileOver: boolean) => {\n            if (onFileOver) {\n                onFileOver(isFileOver);\n            }\n        };\n\n        let uploadClick: () => void;\n\n        return (\n            <UploadZoneDiv\n                onClick={() => {\n                    if (clickable) {\n                        uploadClick();\n                    }\n                }}\n                onDragEnter={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }}\n                onDragOver={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    onFileOverMaybe(true);\n                }}\n                onDragExit={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    onFileOverMaybe(false);\n                }}\n                onDragEnd={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }}\n                onDrop={(event) => {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    onFileOverMaybe(false);\n\n                    const files = Array.from(event.dataTransfer.files); // TODO: Maybe there should be event.dataTransfer.items handler\n                    onFile(files);\n                }}\n            >\n                <input\n                    type=\"file\"\n                    ref={(element) => {\n                        if (element) {\n                            uploadClick = () => {\n                                onFileOverMaybe(true);\n                                (element as HTMLInputElement).click();\n                            };\n                        }\n                    }}\n                    onChange={(event) => {\n                        if (!event || !event.target || !event.target.files)\n                            return;\n                        onFile(Array.from(event.target.files));\n                    }}\n                />\n\n                {children}\n            </UploadZoneDiv>\n        );\n    }\n}\n\nconst UploadZoneDiv = styled.div`\n    width: ${210}px;\n    height: ${297}px;\n    padding: 10px;\n    border: 5px dashed #009edf;\n\n    input {\n        display: none;\n    }\n`;\n","export function readFile(file: File | Blob): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        // Create file reader\n        let reader = new FileReader();\n\n        // Register event listeners\n        reader.addEventListener('loadend', (event) =>\n            resolve(event.target!.result as ArrayBuffer),\n        );\n        reader.addEventListener('error', reject);\n\n        // Read file\n        reader.readAsArrayBuffer(file);\n    });\n}\n","import { readFile } from './readFile';\n\nexport async function getAsByteArray(file: File | Blob): Promise<Uint8Array> {\n    return new Uint8Array(await readFile(file));\n}\n","export function uint8ArrayToHex(uint8Array: Uint8Array) {\n    return [...uint8Array].map((x) => x.toString(16).padStart(2, '0')).join('');\n}\n","// @ts-ignore: no typings\nimport { blake2bFinal, blake2bInit, blake2bUpdate } from 'blakejs';\nimport { getAsByteArray } from '../utils/getAsByteArray';\nimport { uint8ArrayToHex } from '../utils/uint8ArrayToHex';\n\nexport async function blake2b256(input: File | Blob): Promise<string> {\n    const KEY = null; // optional key\n    const OUTPUT_LENGTH = 32; // bytes\n    const context = blake2bInit(OUTPUT_LENGTH, KEY);\n\n    // each time you get a byte array from the stream:\n    blake2bUpdate(context, await getAsByteArray(input));\n\n    // finally, once the stream has been exhausted\n    const hashUint8Array = blake2bFinal(context);\n    // returns a 64-byte hash, as a Uint8Array\n\n    const hash = uint8ArrayToHex(hashUint8Array);\n\n    return hash;\n}\n","import { IOracle } from './_IOracle';\n\nexport abstract class AbstractBlockcyptherOracle\n    implements IOracle<{ hash: string }>\n{\n    public abstract name: string;\n    public abstract title: string;\n\n    public dataTitles = { hash: 'Current block hash' };\n    public ttl = -1;\n\n    public async getData() {\n        const response = await fetch(\n            `https://api.blockcypher.com/v1/${this.name.toLowerCase()}/main` /*`https://blockchain.info/latestblock`*/,\n            /*{ mode: 'no-cors' }*/\n        );\n        console.log({ response });\n        const body = await response.json();\n\n        if (body.error) {\n            throw new Error(body.error);\n        }\n\n        const { hash } = body;\n        return { hash };\n    }\n}\n","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class BitcoinOracle extends AbstractBlockcyptherOracle {\n    public name = 'BTC';\n    public title = 'Bitcoin';\n}\n","import { IOracle } from './_IOracle';\n\nexport class DateOracle implements IOracle<{ date: string; time: string }> {\n    public name = 'DATE';\n    public title = 'Current';\n    public ttl = 1;\n\n    public dataTitles = { date: 'date', time: 'time' };\n\n    public getData() {\n        const date = new Date();\n        return {\n            date: `${date.getUTCFullYear()}-${('0' + date.getUTCMonth()).slice(\n                -2,\n            )}-${('0' + date.getUTCDate()).slice(-2)}`,\n            time: `${('0' + date.getUTCHours()).slice(-2)}:${(\n                '0' + date.getUTCMinutes()\n            ).slice(-2)}:${('0' + date.getUTCSeconds()).slice(-2)}`,\n        };\n    }\n}\n","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class EthereumOracle extends AbstractBlockcyptherOracle {\n    public name = 'ETH';\n    public title = 'Ethereum';\n}\n","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class LitecoinOracle extends AbstractBlockcyptherOracle {\n    public name = 'LTC';\n    public title = 'Litecoin';\n}\n","import RssParser from 'rss-parser';\nimport { IOracle } from './_IOracle';\n\nexport class NytimesOracle implements IOracle<{ firstTitle: string }> {\n    public name = 'NYTIMES';\n    public title = 'The New York Times';\n    public ttl = -1;\n\n    public dataTitles = { firstTitle: 'first title' };\n\n    public async getData() {\n        const rssParser = new RssParser();\n        const feed = await rssParser.parseURL(\n            `https://rss.nytimes.com/services/xml/rss/nyt/World.xml`,\n        );\n\n        // console.log({ feed });\n\n        return {\n            firstTitle: feed.items[0].title as string,\n        };\n    }\n}\n","export async function getCurrentBlockchainHeight(): Promise<number> {\n    // TODO: Implement, value is hardcoded\n    return 0;\n}\n","import { getCurrentBlockchainHeight } from './getCurrentBlockchainHeight';\nimport { isUserAddressCorrect } from './isUserAddressCorrect';\n\ninterface ICreateSigmaStampNft {\n    documentHashInBase64: string;\n    documentHashInHex: string;\n    userAddress: string;\n}\n\n/**\n * \n * TODO: !!! Split into more granular pieces\n */\nexport async function createSigmaStampNft({\n    userAddress,\n    documentHashInBase64,\n    documentHashInHex,\n}: ICreateSigmaStampNft) /*: Promise<{ amount: number; address: string }> */ {\n    if (!isUserAddressCorrect(userAddress)) {\n        throw new Error(`User address \"${userAddress}\" is not correct.`);\n    }\n\n    const mintingFee = 20000000; /* TODO: User settable */\n    const ergsSendTogetherWithNFT = 100000000; /* TODO: User settable */\n    const ergsFeeForSigmaStampService = 100000000; /* Our fee */\n    const sigmaStampProviderAddress =\n        '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV';\n    const assetTypeValue = 'Ad4=';\n    const returnTransactionFee = 10000000;\n    const sigmaStampAssemblerNodeAddr =\n        '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV';\n    const refundHeightThreshold = (await getCurrentBlockchainHeight()) + 10;\n\n    const sourceInScala = `\n{\n\n    val sigmaStampNftIssuanceOK = {\n        \n        val assetType = OUTPUTS(0).R7[Coll[Byte]].get\n        val stampedDocHash = OUTPUTS(0).R8[Coll[Byte]].get\n        val issued = OUTPUTS(0).tokens.getOrElse(0, (INPUTS(0).id, 0L))\n\n        INPUTS(0).id == issued._1 && issued._2 == 1 &&\n        OUTPUTS(0).value == ${ergsSendTogetherWithNFT}L &&\n\n        OUTPUTS(0).propositionBytes == PK(\"${userAddress}\").propBytes &&\n        OUTPUTS(1).value == ${ergsFeeForSigmaStampService}L &&\n\n        OUTPUTS(1).propositionBytes == PK(\"${sigmaStampProviderAddress}\").propBytes &&\n        assetType == fromBase64(\"${assetTypeValue}\") &&\n        stampedDocHash == fromBase64(\"${documentHashInBase64}\") &&\n        OUTPUTS.size == 3\n\n    }\n\n    val returnFunds = {\n\n        val total_without_fee = INPUTS.fold(0L, {(x:Long, b:Box) => x + b.value}) - ${returnTransactionFee}L\n\n        OUTPUTS(0).value >= total_without_fee &&\n        OUTPUTS(0).propositionBytes == PK(\"${userAddress}\").propBytes &&\n        (PK(\"${sigmaStampAssemblerNodeAddr}\") || HEIGHT > ${refundHeightThreshold}) &&\n        OUTPUTS.size == 2\n\n    }\n\n    sigmaProp(sigmaStampNftIssuanceOK || returnFunds)\n\n}\n    `;\n\n    const body = JSON.stringify(sourceInScala.trim())\n        .split('^\\n')\n        .join('\\n')\n        .split('\\n\\n')\n        .join('\\n');\n\n    //console.log(sourceInScala, body, bodyx);\n\n    // TODO: !!! Not working compilation\n    const compilerResponse = await fetch(\n        `http://assembler.sigmastamp.ml:14747/compile`,\n        {\n            method: 'POST',\n            body,\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        },\n    );\n    const compilerResponseBody = await compilerResponse.json();\n\n    const compiledSmartContractAddress = compilerResponseBody.address;\n    const ergoAmountRequired =\n        ergsSendTogetherWithNFT + ergsFeeForSigmaStampService + mintingFee;\n    const documentHashInErgoFormat = `e20${documentHashInHex}`;\n    const verifyLinkInErgoFormat = `0e61${\n        /* !!! Convert to hex */ `http://sigmastamp.ml/verify?hash=a16d5705c031866f5c5dd1ba39e43538193b45718af5a50a115e1c8d67c209cd`\n    }`;\n\n    const requestBody = {\n        address: compiledSmartContractAddress,\n        returnTo: userAddress,\n        startWhen: { erg: ergoAmountRequired },\n        txSpec: {\n            requests: [\n                {\n                    ergValue: ergsSendTogetherWithNFT,\n                    address: userAddress,\n                    name: 'SigmaStampNFT',\n                    amount: 1,\n                    decimals: 0,\n                    description:\n                        'Proof of existence of document with Blake2b-256 hash specified in R8 register during minting of this NFT token.',\n                    registers: {\n                        R7: '0e0201de',\n                        R8: documentHashInErgoFormat,\n                        R9: verifyLinkInErgoFormat,\n                    },\n                },\n                {\n                    value: ergsFeeForSigmaStampService,\n                    address: sigmaStampProviderAddress,\n                },\n            ],\n            fee: mintingFee,\n            inputs: ['$userIns'],\n            dataInputs: [],\n        },\n    };\n\n    const followResponse = await fetch(\n        `http://assembler.sigmastamp.ml:14747/follow`,\n        {\n            method: 'POST',\n            body: JSON.stringify(requestBody),\n        },\n    );\n\n    const followResponseBody = await followResponse.json();\n    const { id, dueTime } = followResponseBody;\n\n    return {\n        amount: ergoAmountRequired / 1000000000,\n        address: compilerResponseBody.address,\n        dueTime,\n        async getStatus() {\n            // Loop\n            const watchResponse = fetch(\n                `http://assembler.sigmastamp.ml:14747/result/${id}`,\n            );\n            const watchResponseBody = await followResponse.json();\n            const {\n                /*id,*/ tx,\n                detail /* pending, returning, mined, success, timeout, returnFailed */,\n            } = followResponseBody;\n\n            console.log({ watchResponse, watchResponseBody, tx });\n\n            if (detail === 'success') {\n                // !!! And now take tx and create big certificate\n\n                return true;\n            }\n\n            return false;\n        },\n    };\n}\n","import { saveAs } from 'file-saver';\nimport JSZip from 'jszip';\nimport React, { useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { AsyncContentComponent } from './components/AsyncContentComponent';\nimport { IPaymentGateProps, PaymentGate } from './components/PaymentGate';\nimport { PdfPage } from './components/PdfPage';\nimport { UploadZone } from './components/UploadZone';\nimport { blake2b256 } from './hash/blake2b256';\nimport { BitcoinOracle } from './oracles/BitcoinOracle';\nimport { DateOracle } from './oracles/DateOracle';\nimport { EthereumOracle } from './oracles/EthereumOracle';\nimport { LitecoinOracle } from './oracles/LitecoinOracle';\nimport { NytimesOracle } from './oracles/NytimesOracle';\nimport { createSigmaStampNft } from './smartcontracts/createSigmaStampNft';\n\nconst ORACLES = [\n    new BitcoinOracle(),\n    new EthereumOracle(),\n    new LitecoinOracle(),\n    new DateOracle(),\n    new NytimesOracle(),\n];\n\ninterface IAppState {\n    files: File[];\n}\n\nexport function App() {\n    const [state, setState] = useState<IAppState>({ files: [] });\n    const [payment, setPayment] = useState<null | IPaymentGateProps>(null);\n\n    if (!payment) {\n        return (\n            <AppDiv>\n                {/*\n        <button\n          onClick={() => { console.log('test'); createCertificate() }}\n        >\n          Create document\n        </button>\n            <h1>Sigmastamp</h1>*/}\n\n                {state.files.length === 0 ? (\n                    <UploadZone\n                        onFiles={async (files) => {\n                            setState({ files });\n                            /*\n                    const file = files[0];\n\n                    const hash = await blake2b256(file);\n\n                    console.log({ files, file, hash });\n\n                    const certificateFile = createCertificate({ certificateFilename: 'certificate.pdf', hash });\n\n                    const zip = new JSZip();\n                    zip.file(file.name, file);\n                    zip.file(certificateFile.name, certificateFile);\n\n                    const zipFile = await zip.generateAsync({ type: 'blob' });\n                    saveAs(zipFile, 'certificate.zip');\n                    */\n                        }}\n                        clickable\n                    >\n                        Upload your file(s) here!\n                    </UploadZone>\n                ) : (\n                    <PdfPage\n                        createUi={({ createPdf }) => {\n                            return (\n                                <button\n                                    onClick={async () => {\n                                        const certificateFile = new File(\n                                            [await createPdf()],\n                                            'certificate1.pdf' /* TODO: Maybe add current {lastModified: 1534584790000}*/,\n                                        );\n\n                                        //saveAs(certificateFile);\n\n                                        const zip = new JSZip();\n                                        for (const file of state.files) {\n                                            zip.file(file.name, file);\n                                        }\n                                        zip.file(\n                                            certificateFile.name,\n                                            certificateFile,\n                                        );\n\n                                        const zipBlob = await zip.generateAsync(\n                                            { type: 'blob' },\n                                        );\n\n                                        const zipHash = await blake2b256(\n                                            zipBlob,\n                                        );\n                                        saveAs(\n                                            zipBlob,\n                                            `certificate1.${zipHash.substring(\n                                                0,\n                                                5,\n                                            )}.zip`,\n                                        );\n\n                                        const userAddress = prompt(\n                                            'Please fill your Ergo address',\n                                            '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV' /* !!! Unhardocde */,\n                                        );\n                                        if (!userAddress) {\n                                            return;\n                                        }\n\n                                        const payment =\n                                            await createSigmaStampNft({\n                                                userAddress,\n                                                documentHashInBase64: zipHash,\n                                                documentHashInHex: zipHash,\n                                            });\n\n                                        setPayment(payment);\n                                    }}\n                                >\n                                    Download 1st certificate\n                                </button>\n                            );\n                        }}\n                    >\n                        {state.files.map((file) => (\n                            <AsyncContentComponent\n                                key={file.name}\n                                content={async () => {\n                                    const hash = await blake2b256(file);\n                                    return (\n                                        <>\n                                            <b>Hash of {file.name}</b> is {hash}\n                                        </>\n                                    );\n                                }}\n                            />\n                        ))}\n\n                        {ORACLES.map((oracle) => (\n                            <div key={oracle.name}>\n                                <AsyncContentComponent\n                                    content={async () => {\n                                        const data = await oracle.getData();\n\n                                        return (\n                                            <>\n                                                {Object.entries(data).map(\n                                                    ([key, value]) => (\n                                                        <div key={key}>\n                                                            <b>\n                                                                {/* @ts-ignore: Object.entries is dummy and cannot pass propper index signature type */}\n                                                                {oracle.title}\n                                                                {\n                                                                    (\n                                                                        oracle as any\n                                                                    )\n                                                                        .dataTitles[\n                                                                        key\n                                                                    ]\n                                                                }\n                                                                :\n                                                            </b>\n                                                            {value}\n                                                        </div>\n                                                    ),\n                                                )}\n                                            </>\n                                        );\n                                    }}\n                                />\n                            </div>\n                        ))}\n                    </PdfPage>\n                )}\n\n                <Link to=\"/verify\" target={'_blank'}>\n                    Or verify your 1st certificate.\n                </Link>\n            </AppDiv>\n        );\n    } else {\n        return <PaymentGate {...payment} />;\n    }\n}\n\nconst AppDiv = styled.div`\n    a {\n        color: #555;\n        font-size: 0.7em;\n    }\n`;\n","import { blake2b256 } from '../hash/blake2b256';\n\nexport async function validateFirstCertificate(firstCertificate: File) {\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v0/assets/issuingBoxes`,\n    );\n    const body = await response.json();\n\n    const hash = await blake2b256(firstCertificate);\n\n    for (const item of body.items) {\n        if (item.additionalRegisters['R8'] === `0e20${hash}`) {\n            return item;\n            // TODO: probbably last not first\n        }\n    }\n\n    return null;\n}\n\nexport async function getTransactionTime(txId: string) {\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v0/transactions/${txId}`,\n    );\n    const body = await response.json();\n    console.log('getTransactionTime', body);\n    const timestamp = body.summary.timestamp;\n    const tokenId = body.outputs[0].assets[0].tokenId;\n\n    return { timestamp, tokenId };\n}\n\nexport async function getAssetHolders(tokenId: string) {\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v0/addresses/assetHolders/${tokenId}`,\n    );\n    const body = await response.json();\n    console.log('getAssetHolders', body);\n    return body;\n}\n","import JSZip from 'jszip';\nimport React, { useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { PdfPage } from './components/PdfPage';\nimport { UploadZone } from './components/UploadZone';\nimport { blake2b256 } from './hash/blake2b256';\nimport {\n    getAssetHolders,\n    getTransactionTime,\n    validateFirstCertificate,\n} from './smartcontracts/validateFirstCertificate';\n\nexport function VerifyApp() {\n    const [files, setFiles] = useState<any>([]);\n    const [verification, setVerification] = useState<any>(null);\n\n    if (!verification) {\n        return (\n            <VerifyAppDiv>\n                <UploadZone\n                    onFiles={async (files) => {\n                        const firstCertificate = files[0];\n                        setFiles([files[0]]);\n\n                        const verification = await validateFirstCertificate(\n                            firstCertificate,\n                        );\n\n                        if (!verification) {\n                            alert(\n                                `Your 1st certificate is still not validated through Ergo blockchain.`,\n                            );\n                        }\n\n                        const { txId } = verification;\n\n                        const { timestamp, tokenId } = await getTransactionTime(\n                            txId,\n                        );\n                        const hodlers = await getAssetHolders(tokenId);\n\n                        setVerification({\n                            ...verification,\n                            timestamp,\n                            tokenId,\n                            hodlers,\n                        });\n                        console.log(verification);\n                    }}\n                    clickable\n                >\n                    Upload your 1st certificate.\n                </UploadZone>\n                <Link to=\"/\" target={'_blank'}>\n                    Or create your 1st certificate.\n                </Link>\n            </VerifyAppDiv>\n        );\n    } else {\n        return (\n            <PdfPage\n                createUi={({ createPdf }) => {\n                    return (\n                        <button\n                            onClick={async () => {\n                                const certificateFile = new File(\n                                    [await createPdf()],\n                                    'certificate2.pdf' /* TODO: Maybe add current {lastModified: 1534584790000}*/,\n                                );\n\n                                //saveAs(certificateFile);\n\n                                const zip = new JSZip();\n                                for (const file of files) {\n                                    zip.file(file.name, file);\n                                }\n                                zip.file(certificateFile.name, certificateFile);\n\n                                const zipBlob = await zip.generateAsync({\n                                    type: 'blob',\n                                });\n\n                                const zipHash = await blake2b256(zipBlob);\n                                saveAs(\n                                    zipBlob,\n                                    `certificate2.${zipHash.substring(\n                                        0,\n                                        5,\n                                    )}.zip`,\n                                );\n                            }}\n                        >\n                            Download 2nd certificate\n                        </button>\n                    );\n                }}\n            >\n                <b>txId:</b> {verification.txId}\n                <br />\n                <b>timestamp:</b> {verification.timestamp}\n                <br />\n                <b>tokenId:</b> {verification.tokenId}\n                <br />\n                <b>hodlers:</b> {verification.hodlers.join(', ')}\n            </PdfPage>\n        );\n    }\n}\n\nconst VerifyAppDiv = styled.div`\n    a {\n        color: #555;\n        font-size: 0.7em;\n    }\n`;\n","import { createHashHistory } from 'history';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Route, Router, Switch } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { App } from './App';\nimport './index.css';\nimport { VerifyApp } from './VerifyApp';\n\nconst history = createHashHistory();\n\nconst HeaderElement = styled.header`\n    h1 {\n        font-size: 1em;\n    }\n`;\n\nReactDOM.render(\n    <React.StrictMode>\n        <HeaderElement>\n            <h1>📜 Sigmastamp</h1>\n        </HeaderElement>\n        <Router {...{ history: history }}>\n            <Switch>\n                <Route exact path=\"/\">\n                    <App />\n                </Route>\n                <Route exact path=\"/verify\">\n                    <VerifyApp />\n                </Route>\n            </Switch>\n        </Router>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}